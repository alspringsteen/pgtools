Postgis Historisation
Dr. Horst Duester (Kanton Solothurn, horst dot duester at kappasys dot ch)
Dr. Andreas Neumann (Stadt Uster, Andreas dot Neumann at Stadt-Uster dot ch) 

%! target       : html
%! style        : style.css
%! Options      : --toc --toc-level 3 --enum-title --css-sugar --css-inside
%! preproc      : TUT_URL   https://qgis.org
%! PostProc(html): '(?i)(<pre>)' '<div class="code">\1'
%! PostProc(html): '(?i)(</pre>)' '\1</div>'
%! encoding: iso-8859-1
% These are comments and will not be generated in any output
% -------------------

%This document is in text2tags format. You can generate html, plain text and
%moinmoin formatted documentation by running txt2tags on this document. See the
%txt2tags home page for more details.  Please insert manual line breaks in this
%document as it makes diffing for changes much easier. To do this in vim 
%automatically, select a section then issue (gq) command. Please dont
%apply vim formatting to the whol document as it screws up some formatting
%rather apply it selectively to paragraphs where needed.

% To generate the text version of this document:
% txt2tags -t txt -o index index.t2t
% To generate the moinmoin version of this document
% txt2tags -t moin -o index.moin  index.t2t
% To generate the html version of this document
% txt2tags -t html -o index.html index.t2t

% End of comments
% -------------------

= Why historisation? =

    - Time is an important dimension in GIS (often neglected in the past)
    - Ability to reconstruct past state of a dataset
    - Simpler database management:
          - No file-based copies
          - Consistent, stable data structure throughout history of a dataset
    - Traceability: who changed when what data - and what did he change?
    - Law/bills: in some countries organisations are required to historise and archive geographic datasets. As an example in Switzerland the recently introduced "GeoIG" (GeoIV, Abschnitt 5) requests historisation of certain datasets.
    -

= Goals of a historisation implementation =
The following requirements should be taken into account when implementing historisation:

    - Should be automatable
    - Should require only low maintenance
    - Should allow manual overriding (e.g. disabling triggers/rules)
    - Should not require adaptations of desktop GIS and Web-GIS
    - Should keep good performance and low storage demands in mind
    -
    
= The approaches =

The following is common to both approaches:

     - Data is never deleted, but deleted or updated records are archived
     - All data is stored in a central table (both current and past data)
     - The current data state can be retrieved and manipulated through a view
     - Every record has at least the following three additional columns:
          - create_date
          - archive_date
          - id (in addition to "gid", allows traceability)
     - A record may have the following additional columns:
          - create_user
          - last_user ch columns had been changed)
     - Both approaches listed below don't yet have a conflict detection for the case that two or more people work on the same dataset at the same time
    
    
== Repository approach ==

The repository approach developed by the Kanton of Solothurn (SO!GIS) allows data to be checked out, revised externally (potentially in completely different software) and to be checked in again. Alternatively, one can just import data from external production systems and store the data in a central, historised respository. The advantage is that data consistency is always guaranteed.

The function ``updatelayer()`` - see download below - first runs the following checks before doing the updates:

    - Are both tables existing in the specified schemas
    - What are the names of the geometry_columns, are they of the same geometry type and are they registered in the "geometry_columns" table?
    - Are the data structures equivalent?
    - Are the primary keys existing?
    - Are the columns necessary for the historisation exist in the historised repository table?
    -

After the checks ran successfully the actual data synchronsation can take place. In a first step, the script finds all records that exist in the old repository table, but not in the new table to be checked in. These records are archived as deleted in the repository table. As a second step the script finds all records that are present in the new table, but not in the repository. Those records are retrieved into the repository and marked as new inserts.

== Live historisation approach ==



For the live historisation approach developed by the City of Uster (based on existing work in PostgreSQL, e.g. [TimeTravel by Varlena http://www.varlena.com/GeneralBits/Tidbits/tt.pdf]), we first need to import two trigger functions written in pl/Perl. You need to load the two trigger functions ``insert_timegis()`` and ``update_timegis()`` listed in the download section below. They are best imported into the "public" schema. Next you have to do the following 6 steps, which can be automated by the script ``add_history()``, also available below:

   1. Create additional columns required for the historisation (see above)
   2. Create a delete rule on the master repository table
   3. Create insert and update row-level before triggers for insert and update that call the two functions ``insert_timegis()`` and ``update_timegis()``
   4. Create indizes on the master table, specifically for create_date and archive_date
   5. Create a view representing the current data state
   6. Create rules (insert, update and delete) to enable data manipulation on the current view
   
= Downloads =

FOSSGIS 2009 article "[Historisierung von PostGIS-Daten als Grundlage zur Langzeitarchivierung von Geodaten http://www.kappasys.ch/pgtools/pghistory/postgis_historisierung_fossgis2009_neumann_duester.pdf" (german) explaining the historisation principles.   

== Repository approach ==

updatelayer()
```
Goal: synchronise external data source with historised repository.

Syntax:

updatelayer(new_schema.new_table,historised_schema.historised_table)
```
[updatelayer()  http://www.kappasys.ch/pgtools/pghistory/updatelayer.sql], pl/PgSQL, by Horst Duester, Kanton Solothurn


== Live historisation approach ==
```
insert_timegis() trigger function
```
[insert_timegis() http://www.kappasys.ch/pgtools/pghistory/insert_timegis_trigger_function.sql], pl/Perl, by Andreas Neumann, City of Uster

```
update_timegis() trigger function
```
[update_timegis() http://www.kappasys.ch/pgtools/pghistory/update_timegis_trigger_function.sql], pl/Perl, by Andreas Neumann, City of Uster


add_history() function
```
Goal: add necessary columns, triggers, rules, indizes and views for historised datasets.

Syntax:

add_history('name_schema','name_table','name_schema_view','name_view')
```
[add_history() http://www.kappasys.ch/pgtools/pghistory/add_history.sql], pl/Perl, by Andreas Neumann, City of Uster


== Sample data (SQL dump) ==

Goal: historised dataset to experiment with. Please create schema "test", as this SQL script creates a table and view in the schema "test". It also assumes that the above listed trigger functions "insert_timegis()" and "update_timegis()" are present. Assumes utf-8 encoding.

[historised_table_example.sql http://www.kappasys.ch/pgtools/pghistory/historised_table_example.sql], by Andreas Neumann, City of Uster


